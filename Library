-- Kaze-style Neon UI Library (2026-01-11) — Final fixes
-- Summary of fixes in this build:
-- 1) Dropdown style changed to match your example: floating menu opens below/right of the selection button,
--    aligns to the selection's right edge and uses same visual style as the main UI.
-- 2) Floating dropdown uses very high ZIndex and won't be occluded. It is parented to ScreenGui (no layout impact).
-- 3) Scrollable areas (tabs column and page content) are proper ScrollingFrames and include single-finger touch drag support
--    so you won't need "two fingers" to scroll on mobile.
-- 4) Elements no longer "escape" to the side — containers are full-width and the list layout controls positioning.
-- 5) All text is pure white and TextStrokeTransparency is forced to 1 (removes the glowing text outline).
-- 6) Removed any accidental stroke on text objects and normalized text for all elements.
-- 7) Slider remains responsive while preventing camera rotation during drag.
--
-- Usage: same API as before:
-- local Library = loadstring(game:HttpGet(".../UI.lua"))()
-- local Window = Library:MakeWindow({Title="..."})
-- local Tab = Window:MakeTab({Name="Main"})
-- local Section = Tab:AddSection("Section Example!")
-- Section:AddButton{...}, Tab:AddSlider{...}, etc.

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UIS = game:GetService("UserInputService")
local LP = Players.LocalPlayer

-- Destroy previous instance to prevent duplicates
if LP:FindFirstChild("PlayerGui") then
	local prev = LP.PlayerGui:FindFirstChild("KazeUI")
	if prev then pcall(function() prev:Destroy() end) end
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KazeUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ScreenGui.Parent = LP:WaitForChild("PlayerGui")

local UIScale = Instance.new("UIScale", ScreenGui)
local function UpdateScale()
	local cam = workspace.CurrentCamera
	local size = cam and cam.ViewportSize or Vector2.new(1920,1080)
	if size.X < 600 then
		UIScale.Scale = math.clamp(size.X / 800, 0.5, 1)
	else
		UIScale.Scale = math.clamp(size.X / 1920, 0.6, 1)
	end
end
pcall(UpdateScale)
if workspace.CurrentCamera then
	workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(UpdateScale)
end

local function FormatImage(id)
	if not id then return "" end
	id = tostring(id)
	local digits = string.gsub(id, "%D", "")
	if digits == "" then return "" end
	return "rbxassetid://" .. digits
end

local function MakeDraggable(dragPart, targetPart)
	local dragging = false
	local dragInput, dragStart, startPos
	local function update(input)
		if not dragStart or not startPos then return end
		local delta = input.Position - dragStart
		targetPart.Position = UDim2.new(
			startPos.X.Scale, startPos.X.Offset + delta.X,
			startPos.Y.Scale, startPos.Y.Offset + delta.Y
		)
	end
	dragPart.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = targetPart.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					dragInput = nil
				end
			end)
		end
	end)
	dragPart.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			dragInput = input
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if input == dragInput and dragging then update(input) end
	end)
end

local function ApplyNeonStroke(inst, thickness)
	thickness = thickness or 2
	local stroke = Instance.new("UIStroke")
	stroke.Color = Color3.fromRGB(0,160,255)
	stroke.Thickness = thickness
	stroke.Parent = inst
	spawn(function()
		while inst and inst.Parent do
			pcall(function()
				local tw = TweenService:Create(stroke, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Color = Color3.fromRGB(0,255,255)})
				tw:Play()
			end)
			break
		end
	end)
	return stroke
end

-- Ensure a gui object's text objects use white and have no stroke/glow
local function NormalizeTextRecursively(gui)
	if not gui then return end
	if gui:IsA("TextLabel") or gui:IsA("TextButton") or gui:IsA("TextBox") then
		gui.TextColor3 = Color3.fromRGB(255,255,255)
		-- some environments support TextStrokeTransparency, set to 1 to remove stroke
		pcall(function() gui.TextStrokeTransparency = 1 end)
		-- also ensure any TextStrokeColor is subdued (not needed but safe)
		pcall(function() gui.TextStrokeColor3 = Color3.new(0,0,0) end)
	end
	for _,c in ipairs(gui:GetChildren()) do NormalizeTextRecursively(c) end
end

local Library = {}
Library.__index = Library

function Library:MakeWindow(config)
	config = config or {}
	local Title = config.Title or "Kaze UI"
	local SubTitle = config.SubTitle or ""
	local MainIcon = FormatImage(config.Icon or "6031763447")
	local MiniButtonSize = UDim2.fromOffset(60,60)

	local Window = Instance.new("Frame")
	Window.Name = "KazeWindow"
	Window.Size = UDim2.fromOffset(650,420)
	Window.Position = UDim2.fromScale(0.5,0.5)
	Window.AnchorPoint = Vector2.new(0.5,0.5)
	Window.BackgroundColor3 = Color3.fromRGB(20,20,25)
	Window.BorderSizePixel = 0
	Window.Parent = ScreenGui
	Instance.new("UICorner", Window).CornerRadius = UDim.new(0,14)
	Window.ClipsDescendants = true
	ApplyNeonStroke(Window, 2.5)

	-- Top bar
	local TopBar = Instance.new("Frame", Window)
	TopBar.Name = "TopBar"
	TopBar.Size = UDim2.new(1,0,0,56)
	TopBar.Position = UDim2.new(0,0,0,0)
	TopBar.BackgroundColor3 = Color3.fromRGB(15,15,20)
	Instance.new("UICorner", TopBar).CornerRadius = UDim.new(0,14)
	MakeDraggable(TopBar, Window)

	local Icon = Instance.new("ImageLabel", TopBar)
	Icon.Size = UDim2.fromOffset(32,32)
	Icon.Position = UDim2.fromOffset(14,12)
	Icon.BackgroundTransparency = 1
	Icon.Image = MainIcon
	Instance.new("UICorner", Icon).CornerRadius = UDim.new(1,0)

	local TitleLabel = Instance.new("TextLabel", TopBar)
	TitleLabel.Size = UDim2.new(1,-160,0,22)
	TitleLabel.Position = UDim2.fromOffset(56,8)
	TitleLabel.BackgroundTransparency = 1
	TitleLabel.Text = Title
	TitleLabel.Font = Enum.Font.GothamBold
	TitleLabel.TextSize = 16
	TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
	NormalizeTextRecursively(TitleLabel)

	local SubLabel = Instance.new("TextLabel", TopBar)
	SubLabel.Size = UDim2.new(1,-160,0,18)
	SubLabel.Position = UDim2.fromOffset(56,30)
	SubLabel.BackgroundTransparency = 1
	SubLabel.Text = SubTitle
	SubLabel.Font = Enum.Font.Gotham
	SubLabel.TextSize = 13
	SubLabel.TextXAlignment = Enum.TextXAlignment.Left
	NormalizeTextRecursively(SubLabel)

	local Minimize = Instance.new("TextButton", TopBar)
	Minimize.Size = UDim2.fromOffset(36,36)
	Minimize.Position = UDim2.new(1,-88,0.5,-18)
	Minimize.Text = "—"
	Minimize.Font = Enum.Font.GothamBold
	Minimize.TextSize = 20
	Minimize.BackgroundColor3 = Color3.fromRGB(25,25,30)
	Instance.new("UICorner", Minimize).CornerRadius = UDim.new(1,0)
	NormalizeTextRecursively(Minimize)

	local Close = Instance.new("TextButton", TopBar)
	Close.Size = UDim2.fromOffset(36,36)
	Close.Position = UDim2.new(1,-44,0.5,-18)
	Close.Text = "✕"
	Close.Font = Enum.Font.GothamBold
	Close.TextSize = 18
	Close.BackgroundColor3 = Color3.fromRGB(25,25,30)
	Instance.new("UICorner", Close).CornerRadius = UDim.new(1,0)
	NormalizeTextRecursively(Close)

	local Content = Instance.new("Frame", Window)
	Content.Position = UDim2.fromOffset(0,56)
	Content.Size = UDim2.new(1,0,1,-56)
	Content.BackgroundTransparency = 1

	-- Tabs column (scrolling)
	local TabsFrame = Instance.new("Frame", Content)
	TabsFrame.Name = "TabsFrame"
	TabsFrame.Size = UDim2.new(0,140,1,0)
	TabsFrame.Position = UDim2.new(0,0,0,0)
	TabsFrame.BackgroundTransparency = 1

	local tabsList = Instance.new("ScrollingFrame", TabsFrame)
	tabsList.Name = "TabsList"
	tabsList.Size = UDim2.new(1,0,1,0)
	tabsList.CanvasSize = UDim2.new(0,0,0,0)
	tabsList.AutomaticCanvasSize = Enum.AutomaticSize.Y
	tabsList.ScrollBarThickness = 8
	tabsList.BackgroundColor3 = Color3.fromRGB(18,18,22)
	tabsList.BorderSizePixel = 0
	Instance.new("UICorner", tabsList).CornerRadius = UDim.new(0,12)
	ApplyNeonStroke(tabsList, 2)

	local TabsLayout = Instance.new("UIListLayout", tabsList)
	TabsLayout.Padding = UDim.new(0,10)
	TabsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	TabsLayout.SortOrder = Enum.SortOrder.LayoutOrder

	-- Pages container
	local Pages = Instance.new("Frame", Content)
	Pages.Name = "Pages"
	Pages.Size = UDim2.new(1, -140, 1, 0)
	Pages.Position = UDim2.new(0,140,0,0)
	Pages.BackgroundTransparency = 1

	local pageTable = {}

	local function hideAllPages()
		for _,p in ipairs(pageTable) do
			if p.Page then p.Page.Visible = false end
			if p.TabButton then p.TabButton.Active = true end
		end
	end

	-- close floating dropdown helper
	local openFloating = nil
	local function closeFloating()
		if openFloating and openFloating.Parent then pcall(function() openFloating:Destroy() end) end
		openFloating = nil
	end

	UIS.InputBegan:Connect(function(input, processed)
		if openFloating and input.UserInputType == Enum.UserInputType.MouseButton1 then
			local target = input.Target
			local inside = false
			if target then
				local p = target
				while p and p ~= ScreenGui.Parent do
					if p == openFloating then inside = true break end
					p = p.Parent
				end
			end
			if not inside then closeFloating() end
		end
	end)

	-- helper: enables single-finger touch scroll for a ScrollingFrame
	local function EnableSingleFingerTouchScroll(scrollingFrame)
		local dragging = false
		local dragInput = nil
		local dragStart = Vector2.new()
		local startCanvas = Vector2.new()
		scrollingFrame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
				dragging = true
				dragInput = input
				dragStart = input.Position
				startCanvas = scrollingFrame.CanvasPosition
			end
		end)
		scrollingFrame.InputChanged:Connect(function(input)
			if input == dragInput then
				-- nothing here; actual updates handled in UIS.InputChanged
			end
		end)
		UIS.InputChanged:Connect(function(input)
			if dragging and input == dragInput and (input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseMovement) then
				local delta = input.Position - dragStart
				local newY = math.clamp(startCanvas.Y - delta.Y, 0, math.max(0, scrollingFrame.CanvasSize.Y.Offset - scrollingFrame.AbsoluteSize.Y))
				pcall(function() scrollingFrame.CanvasPosition = Vector2.new(scrollingFrame.CanvasPosition.X, newY) end)
			end
		end)
		UIS.InputEnded:Connect(function(input)
			if input == dragInput then
				dragging = false
				dragInput = nil
			end
		end)
	end

	local function CreateTab(tbl)
		tbl = tbl or {}
		local name = tbl.Name or ("Tab"..(#pageTable+1))
		local icon = FormatImage(tbl.Icon or "")

		local TabBtn = Instance.new("TextButton")
		TabBtn.Name = "TabBtn_"..name
		TabBtn.Size = UDim2.new(1,-16,0,44)
		TabBtn.BackgroundColor3 = Color3.fromRGB(25,25,30)
		TabBtn.BorderSizePixel = 0
		TabBtn.LayoutOrder = #pageTable + 1
		TabBtn.Parent = tabsList
		Instance.new("UICorner", TabBtn).CornerRadius = UDim.new(0,10)
		ApplyNeonStroke(TabBtn, 2)

		local btnIcon = Instance.new("ImageLabel", TabBtn)
		btnIcon.Size = UDim2.fromOffset(28,28)
		btnIcon.Position = UDim2.fromOffset(8,8)
		btnIcon.BackgroundTransparency = 1
		btnIcon.Image = icon
		Instance.new("UICorner", btnIcon).CornerRadius = UDim.new(1,0)

		local btnLabel = Instance.new("TextLabel", TabBtn)
		btnLabel.Size = UDim2.new(1,-44,1,0)
		btnLabel.Position = UDim2.fromOffset(44,0)
		btnLabel.BackgroundTransparency = 1
		btnLabel.Text = name
		btnLabel.Font = Enum.Font.GothamBold
		btnLabel.TextSize = 14
		btnLabel.TextXAlignment = Enum.TextXAlignment.Left
		NormalizeTextRecursively(btnLabel)

		-- Page is a ScrollingFrame
		local Page = Instance.new("ScrollingFrame")
		Page.Name = name.."_Page"
		Page.Size = UDim2.new(1,0,1,0)
		Page.Position = UDim2.new(0,0,0,0)
		Page.BackgroundColor3 = Color3.fromRGB(20,20,25)
		Page.BorderSizePixel = 0
		Page.Parent = Pages
		Page.Visible = false
		Page.ScrollBarThickness = 10
		Page.ClipsDescendants = true
		Instance.new("UICorner", Page).CornerRadius = UDim.new(0,12)
		ApplyNeonStroke(Page, 1.5)

		local PagePadding = Instance.new("UIPadding", Page)
		PagePadding.PaddingTop = UDim.new(0,12)
		PagePadding.PaddingLeft = UDim.new(0,12)
		PagePadding.PaddingRight = UDim.new(0,12)
		PagePadding.PaddingBottom = UDim.new(0,12)

		-- We'll put content directly in Page and use UIListLayout
		local LayoutParent = Instance.new("Frame", Page)
		LayoutParent.Size = UDim2.new(1,0,0,0)
		LayoutParent.BackgroundTransparency = 1
		LayoutParent.Name = "PageList"

		local Layout = Instance.new("UIListLayout", LayoutParent)
		Layout.SortOrder = Enum.SortOrder.LayoutOrder
		Layout.Padding = UDim.new(0,10)
		-- update canvas size when children change
		Layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			local y = Layout.AbsoluteContentSize.Y
			Page.CanvasSize = UDim2.new(0,0,0, y + 16)
		end)

		-- enable single-finger drag scrolling
		EnableSingleFingerTouchScroll(Page)
		EnableSingleFingerTouchScroll(tabsList)

		local function createElementContainer(height, parent)
			parent = parent or LayoutParent
			local container = Instance.new("Frame")
			container.Size = UDim2.new(1,0,0,height or 48)
			container.BackgroundColor3 = Color3.fromRGB(25,25,30)
			container.BorderSizePixel = 0
			container.Parent = parent
			Instance.new("UICorner", container).CornerRadius = UDim.new(0,8)
			ApplyNeonStroke(container, 2)
			return container
		end

		-- Button
		local function AddButton(opts, parent)
			opts = opts or {}
			local container = createElementContainer(48, parent)
			local btn = Instance.new("TextButton", container)
			btn.Size = UDim2.new(1,-12,1,-12)
			btn.Position = UDim2.fromOffset(6,6)
			btn.BackgroundColor3 = Color3.fromRGB(35,35,40)
			btn.BorderSizePixel = 0
			btn.Text = opts.Name or "Button"
			btn.Font = Enum.Font.GothamBold
			btn.TextSize = 14
			NormalizeTextRecursively(btn)
			Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)
			local stroke = ApplyNeonStroke(btn, 2)
			if typeof(opts.Callback) == "function" then
				btn.MouseButton1Click:Connect(function()
					pcall(opts.Callback)
					spawn(function()
						pcall(function()
							local t1 = TweenService:Create(stroke, TweenInfo.new(0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Color = Color3.fromRGB(180,255,255)})
							local t2 = TweenService:Create(stroke, TweenInfo.new(0.36, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Color = Color3.fromRGB(0,160,255)})
							t1:Play()
							t1.Completed:Wait()
							t2:Play()
						end)
					end)
				end)
			end
			return btn
		end

		-- Toggle
		local function AddToggle(opts, parent)
			opts = opts or {}
			local default = opts.Default and true or false
			local container = createElementContainer(52, parent)

			local lbl = Instance.new("TextLabel", container)
			lbl.Size = UDim2.new(0.7,0,1,0)
			lbl.BackgroundTransparency = 1
			lbl.Text = opts.Name or "Toggle"
			lbl.Font = Enum.Font.GothamBold
			lbl.TextSize = 14
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			NormalizeTextRecursively(lbl)

			local toggleFrame = Instance.new("Frame", container)
			toggleFrame.Size = UDim2.new(0,60,0,28)
			toggleFrame.Position = UDim2.new(1,-70,0.5,-14)
			toggleFrame.BackgroundColor3 = Color3.fromRGB(35,35,40)
			Instance.new("UICorner", toggleFrame).CornerRadius = UDim.new(0,14)
			ApplyNeonStroke(toggleFrame, 2)

			local knob = Instance.new("Frame", toggleFrame)
			knob.Size = UDim2.new(0,24,0,24)
			knob.Position = UDim2.new(default and 1 or 0, -(default and 28 or 2), 0.5, -12)
			knob.BackgroundColor3 = default and Color3.fromRGB(0,200,255) or Color3.fromRGB(65,65,70)
			Instance.new("UICorner", knob).CornerRadius = UDim.new(1,0)
			ApplyNeonStroke(knob, 1.6)

			local state = default
			local function setState(s, noCallback)
				state = s
				if state then
					TweenService:Create(knob, TweenInfo.new(0.18), {Position = UDim2.new(1, -28, 0.5, -12), BackgroundColor3 = Color3.fromRGB(0,200,255)}):Play()
				else
					TweenService:Create(knob, TweenInfo.new(0.18), {Position = UDim2.new(0, 2, 0.5, -12), BackgroundColor3 = Color3.fromRGB(65,65,70)}):Play()
				end
				if typeof(opts.Callback) == "function" and not noCallback then pcall(opts.Callback, state) end
			end

			toggleFrame.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					setState(not state)
				end
			end)
			setState(state, true)
			return toggleFrame
		end

		-- Dropdown (floating menu styled to example)
		local function AddDropdown(opts, parent)
			opts = opts or {}
			local options = opts.Options or {}
			local container = createElementContainer(44, parent)

			local lbl = Instance.new("TextLabel", container)
			lbl.Size = UDim2.new(0.45,0,1,0)
			lbl.BackgroundTransparency = 1
			lbl.Text = opts.Name or "Dropdown"
			lbl.Font = Enum.Font.GothamBold
			lbl.TextSize = 14
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			NormalizeTextRecursively(lbl)

			local selection = Instance.new("TextButton", container)
			selection.Size = UDim2.new(0.5,-8,1,0)
			selection.Position = UDim2.new(0.5,0,0,0)
			selection.BackgroundColor3 = Color3.fromRGB(30,30,35)
			selection.Text = opts.Default or "Select..."
			selection.Font = Enum.Font.Gotham
			selection.TextSize = 14
			NormalizeTextRecursively(selection)
			Instance.new("UICorner", selection).CornerRadius = UDim.new(0,8)
			ApplyNeonStroke(selection, 1.8)

			local isOpen = false

			local function openFloating()
				closeFloating()
				-- compute absolute position and sizes
				local absPos = selection.AbsolutePosition
				local absSize = selection.AbsoluteSize
				local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920,1080)
				local floatWidth = math.max(180, absSize.X) -- at least selection width
				local itemH = 36
				local padding = 6
				local totalH = (#options) * (itemH + padding)
				local rightX = absPos.X + absSize.X - floatWidth -- align right edge of float to right edge of selection
				local leftX = absPos.X -- fallback to left-align with selection
				local floatX = rightX
				-- if float goes off-screen to left, clamp
				if floatX < 8 then floatX = leftX end
				-- if float would go off bottom screen, shift up a bit
				local floatY = absPos.Y + absSize.Y + 6
				if (floatY + totalH) > viewport.Y then
					floatY = math.max(8, viewport.Y - totalH - 8)
				end

				local floatFrame = Instance.new("Frame", ScreenGui)
				floatFrame.Name = "FloatingDropdown"
				floatFrame.Size = UDim2.fromOffset(0,0)
				floatFrame.Position = UDim2.fromOffset(floatX, floatY)
				floatFrame.ClipsDescendants = false
				floatFrame.BackgroundTransparency = 1
				floatFrame.ZIndex = 12000

				local containerFrame = Instance.new("Frame", floatFrame)
				containerFrame.Size = UDim2.fromOffset(floatWidth, totalH)
				containerFrame.BackgroundColor3 = Color3.fromRGB(25,25,30)
				containerFrame.BorderSizePixel = 0
				Instance.new("UICorner", containerFrame).CornerRadius = UDim.new(0,8)
				ApplyNeonStroke(containerFrame, 1.8)
				containerFrame.ZIndex = 12001

				local listLayout = Instance.new("UIListLayout", containerFrame)
				listLayout.Padding = UDim.new(0,6)
				listLayout.SortOrder = Enum.SortOrder.LayoutOrder

				for i,opt in ipairs(options) do
					local optBtn = Instance.new("TextButton", containerFrame)
					optBtn.Size = UDim2.new(1,-12,0,itemH)
					optBtn.Position = UDim2.fromOffset(6,0)
					optBtn.BackgroundColor3 = Color3.fromRGB(32,32,36)
					optBtn.Text = tostring(opt)
					optBtn.Font = Enum.Font.Gotham
					optBtn.TextSize = 14
					optBtn.BorderSizePixel = 0
					Instance.new("UICorner", optBtn).CornerRadius = UDim.new(0,6)
					ApplyNeonStroke(optBtn, 1.6)
					NormalizeTextRecursively(optBtn)
					optBtn.ZIndex = 12002

					optBtn.MouseButton1Click:Connect(function()
						selection.Text = tostring(opt)
						if typeof(opts.Callback) == "function" then pcall(opts.Callback, opt) end
						closeFloating()
					end)
				end

				-- open animation
				local target = UDim2.fromOffset(floatWidth, totalH)
				TweenService:Create(floatFrame, TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = target}):Play()
				openFloating = floatFrame
			end

			selection.MouseButton1Click:Connect(function()
				isOpen = not isOpen
				if isOpen then
					-- wait for absolute size when needed
					if selection.AbsoluteSize.X == 0 then
						spawn(function() repeat wait() until selection.AbsoluteSize.X > 0; openFloating() end)
					else openFloating() end
				else closeFloating() end
			end)

			selection:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
				if openFloating then closeFloating() end
			end)

			return selection
		end

		-- Slider
		local function AddSlider(opts, parent)
			opts = opts or {}
			local min = opts.Min or 0
			local max = opts.Max or 100
			local default = opts.Default or min
			local step = opts.Step or 1

			local container = createElementContainer(56, parent)

			local lbl = Instance.new("TextLabel", container)
			lbl.Size = UDim2.new(0.5,0,0,20)
			lbl.BackgroundTransparency = 1
			lbl.Text = opts.Name or "Slider"
			lbl.Font = Enum.Font.GothamBold
			lbl.TextSize = 14
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			NormalizeTextRecursively(lbl)

			local valLabel = Instance.new("TextLabel", container)
			valLabel.Size = UDim2.new(0.5,-12,0,20)
			valLabel.Position = UDim2.new(0.5,0,0,0)
			valLabel.BackgroundTransparency = 1
			valLabel.Text = tostring(default)
			valLabel.Font = Enum.Font.Gotham
			valLabel.TextSize = 14
			valLabel.TextXAlignment = Enum.TextXAlignment.Right
			NormalizeTextRecursively(valLabel)

			local track = Instance.new("Frame", container)
			track.Size = UDim2.new(1,-12,0,12)
			track.Position = UDim2.new(0,6,0,28)
			track.BackgroundColor3 = Color3.fromRGB(35,35,40)
			Instance.new("UICorner", track).CornerRadius = UDim.new(0,6)
			ApplyNeonStroke(track, 1.6)

			local fill = Instance.new("Frame", track)
			fill.Size = UDim2.new(0,0,1,0)
			fill.BackgroundColor3 = Color3.fromRGB(0,200,255)
			Instance.new("UICorner", fill).CornerRadius = UDim.new(0,6)
			ApplyNeonStroke(fill, 1.6)

			local thumb = Instance.new("Frame", track)
			thumb.Size = UDim2.new(0,18,0,18)
			thumb.Position = UDim2.new(0,-9,0.5,-9)
			thumb.BackgroundColor3 = Color3.fromRGB(0,200,255)
			Instance.new("UICorner", thumb).CornerRadius = UDim.new(1,0)
			ApplyNeonStroke(thumb, 1.6)

			local dragging = false
			local prevMouseBehavior = nil
			local inputConn = nil

			local function setFromFraction(frac)
				frac = math.clamp(frac, 0, 1)
				local raw = min + (max - min) * frac
				local stepped = math.floor((raw - min) / step + 0.5) * step + min
				stepped = math.clamp(stepped, min, max)
				local denom = math.max(1, (max - min))
				local frac2 = (stepped - min) / denom
				fill.Size = UDim2.new(frac2,0,1,0)
				thumb.Position = UDim2.new(frac2, -9, 0.5, -9)
				valLabel.Text = tostring(stepped)
				if typeof(opts.Callback) == "function" then pcall(opts.Callback, stepped) end
			end

			local function setFromPosition(x)
				local absolute = track.AbsoluteSize.X
				local relative = math.clamp(x - track.AbsolutePosition.X, 0, absolute)
				local fraction = (absolute <= 0) and 0 or (relative / absolute)
				setFromFraction(fraction)
			end

			track.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
					dragging = true
					pcall(function() prevMouseBehavior = UIS.MouseBehavior; UIS.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition end)
					inputConn = UIS.InputChanged:Connect(function(inpt)
						if dragging and (inpt.UserInputType == Enum.UserInputType.MouseMovement or inpt.UserInputType == Enum.UserInputType.Touch) then
							pcall(function() setFromPosition(inpt.Position.X) end)
						end
					end)
					pcall(function() setFromPosition(input.Position.X) end)
				end
			end)

			track.InputChanged:Connect(function(input)
				if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
					pcall(function() setFromPosition(input.Position.X) end)
				end
			end)

			UIS.InputEnded:Connect(function(input)
				if dragging and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
					dragging = false
					pcall(function()
						if prevMouseBehavior then UIS.MouseBehavior = prevMouseBehavior else UIS.MouseBehavior = Enum.MouseBehavior.Default end
						prevMouseBehavior = nil
					end)
					if inputConn then pcall(function() inputConn:Disconnect() end); inputConn = nil end
				end
			end)

			-- initialize
			spawn(function()
				repeat wait() until track.AbsoluteSize.X > 0
				local frac = (default - min) / math.max(1, (max - min))
				setFromFraction(frac)
			end)

			NormalizeTextRecursively(container)
			return track
		end

		-- Textbox
		local function AddTextBox(opts, parent)
			opts = opts or {}
			local container = createElementContainer(48, parent)
			local box = Instance.new("TextBox", container)
			box.Size = UDim2.new(1,-12,1,-12)
			box.Position = UDim2.fromOffset(6,6)
			box.BackgroundColor3 = Color3.fromRGB(30,30,35)
			box.Text = opts.Default or ""
			box.PlaceholderText = opts.Placeholder or "Enter text..."
			box.ClearTextOnFocus = false
			box.Font = Enum.Font.Gotham
			box.TextSize = 14
			NormalizeTextRecursively(box)
			Instance.new("UICorner", box).CornerRadius = UDim.new(0,6)
			ApplyNeonStroke(box, 1.8)
			box.FocusLost:Connect(function(enter)
				if enter and typeof(opts.Callback) == "function" then pcall(opts.Callback, box.Text) end
			end)
			return box
		end

		-- Section (auto-size-like behaviour via UIListLayout + container)
		local function AddSection(name)
			local sectionFrame = Instance.new("Frame", LayoutParent)
			sectionFrame.Name = "Section"
			sectionFrame.BackgroundTransparency = 1
			sectionFrame.Size = UDim2.new(1,0,0,0) -- height controlled by children / layout
			-- header
			local header = Instance.new("TextLabel", sectionFrame)
			header.Size = UDim2.new(1,0,0,26)
			header.Position = UDim2.new(0,0,0,0)
			header.BackgroundTransparency = 1
			header.Text = name or "Section"
			header.Font = Enum.Font.GothamBold
			header.TextSize = 16
			header.TextColor3 = Color3.fromRGB(0,170,255)
			header.TextXAlignment = Enum.TextXAlignment.Left
			NormalizeTextRecursively(header)

			local list = Instance.new("Frame", sectionFrame)
			list.Size = UDim2.new(1,0,0,0)
			list.Position = UDim2.new(0,0,0,30)
			list.BackgroundTransparency = 1
			local layout = Instance.new("UIListLayout", list)
			layout.SortOrder = Enum.SortOrder.LayoutOrder
			layout.Padding = UDim.new(0,8)

			-- ensure Page.CanvasSize updates will include section children
			Layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
				local y = Layout.AbsoluteContentSize.Y
				Page.CanvasSize = UDim2.new(0,0,0, y + 16)
			end)

			local sectionAPI = {}
			function sectionAPI:AddButton(tbl) return AddButton(tbl, list) end
			function sectionAPI:AddToggle(tbl) return AddToggle(tbl, list) end
			function sectionAPI:AddSlider(tbl) return AddSlider(tbl, list) end
			function sectionAPI:AddDropdown(tbl) return AddDropdown(tbl, list) end
			function sectionAPI:AddTextBox(tbl) return AddTextBox(tbl, list) end
			return sectionAPI
		end

		-- Tab API
		local tabAPI = {}
		tabAPI.Page = Page
		tabAPI.TabButton = TabBtn
		function tabAPI:AddSection(n) return AddSection(n) end
		function tabAPI:AddButton(t) return AddButton(t) end
		function tabAPI:AddToggle(t) return AddToggle(t) end
		function tabAPI:AddSlider(t) return AddSlider(t) end
		function tabAPI:AddDropdown(t) return AddDropdown(t) end
		function tabAPI:AddTextBox(t) return AddTextBox(t) end

		TabBtn.MouseButton1Click:Connect(function()
			hideAllPages()
			Page.Visible = true
			TabBtn.Active = false
		end)

		table.insert(pageTable, tabAPI)
		-- show first created tab for convenience
		if #pageTable == 1 then
			hideAllPages()
			Page.Visible = true
			TabBtn.Active = false
		end

		NormalizeTextRecursively(TabBtn)
		return tabAPI
	end

	-- MiniButton (minimize/restore) left as previously
	local MiniButton = Instance.new("ImageButton", ScreenGui)
	MiniButton.Name = "MiniButton"
	MiniButton.Size = MiniButtonSize
	MiniButton.Position = UDim2.fromScale(0.1, 0.1)
	MiniButton.BackgroundColor3 = Color3.fromRGB(20,20,25)
	MiniButton.BorderSizePixel = 0
	MiniButton.Visible = false
	MiniButton.ZIndex = 999
	MiniButton.ScaleType = Enum.ScaleType.Slice
	MiniButton.SliceCenter = Rect.new(4,4,60,60)
	Instance.new("UICorner", MiniButton).CornerRadius = UDim.new(0,12)
	local MiniIcon = Instance.new("ImageLabel", MiniButton)
	MiniIcon.Size = UDim2.fromScale(1,1)
	MiniIcon.Position = UDim2.fromScale(0.5,0.5)
	MiniIcon.AnchorPoint = Vector2.new(0.5,0.5)
	MiniIcon.BackgroundTransparency = 1
	MiniIcon.Image = MainIcon
	MiniIcon.ZIndex = 1000
	local MiniStroke = Instance.new("UIStroke", MiniButton)
	MiniStroke.Color = Color3.fromRGB(0,160,255); MiniStroke.Thickness = 2.5
	spawn(function()
		while MiniButton.Parent do
			local t = TweenService:Create(MiniStroke, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {Color = Color3.fromRGB(0,255,255)})
			t:Play()
			break
		end
	end)
	MakeDraggable(MiniButton, MiniButton)

	Minimize.MouseButton1Click:Connect(function()
		Window.Visible = false
		MiniButton.Visible = true
		MiniButton.Size = UDim2.fromOffset(0,0)
		TweenService:Create(MiniButton, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = MiniButtonSize}):Play()
	end)
	MiniButton.MouseButton1Click:Connect(function()
		MiniButton.Visible = false
		Window.Visible = true
		Window.Size = UDim2.fromOffset(0,0)
		TweenService:Create(Window, TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.fromOffset(650,420)}):Play()
	end)

	local function ShowCloseConfirm()
		Minimize.Active = false
		Close.Active = false
		local Overlay = Instance.new("Frame", Window)
		Overlay.Size = UDim2.new(1,0,1,0)
		Overlay.BackgroundColor3 = Color3.fromRGB(0,0,0)
		Overlay.BackgroundTransparency = 0.6
		Overlay.ZIndex = 20

		local ConfirmWindow = Instance.new("Frame", Overlay)
		ConfirmWindow.Size = UDim2.fromOffset(350,150)
		ConfirmWindow.AnchorPoint = Vector2.new(0.5,0.5)
		ConfirmWindow.Position = UDim2.fromScale(0.5,0.5)
		ConfirmWindow.BackgroundColor3 = Color3.fromRGB(25,25,30)
		Instance.new("UICorner", ConfirmWindow).CornerRadius = UDim.new(0,12)
		ApplyNeonStroke(ConfirmWindow, 1.8)

		local ConfirmText = Instance.new("TextLabel", ConfirmWindow)
		ConfirmText.Size = UDim2.new(1,-32,0,48)
		ConfirmText.Position = UDim2.fromOffset(16,20)
		ConfirmText.BackgroundTransparency = 1
		ConfirmText.Text = "Are you sure you want to close the UI?"
		ConfirmText.Font = Enum.Font.GothamBold
		ConfirmText.TextSize = 18
		ConfirmText.TextWrapped = true
		NormalizeTextRecursively(ConfirmText)

		local ButtonsFrame = Instance.new("Frame", ConfirmWindow)
		ButtonsFrame.Size = UDim2.new(1,0,0,40)
		ButtonsFrame.Position = UDim2.new(0,0,1,-20)
		ButtonsFrame.AnchorPoint = Vector2.new(0,1)
		ButtonsFrame.BackgroundTransparency = 1

		local layout = Instance.new("UIListLayout", ButtonsFrame)
		layout.FillDirection = Enum.FillDirection.Horizontal
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		layout.Padding = UDim.new(0,16)

		local ConfirmBtn = Instance.new("TextButton", ButtonsFrame)
		ConfirmBtn.Size = UDim2.new(0,120,0,36)
		ConfirmBtn.BackgroundColor3 = Color3.fromRGB(0,170,255)
		ConfirmBtn.Text = "Confirm"
		ConfirmBtn.Font = Enum.Font.GothamBold
		ConfirmBtn.TextSize = 16
		Instance.new("UICorner", ConfirmBtn).CornerRadius = UDim.new(0,8)
		ApplyNeonStroke(ConfirmBtn, 2)
		NormalizeTextRecursively(ConfirmBtn)

		local CancelBtn = Instance.new("TextButton", ButtonsFrame)
		CancelBtn.Size = UDim2.new(0,120,0,36)
		CancelBtn.BackgroundColor3 = Color3.fromRGB(45,45,50)
		CancelBtn.Text = "Cancel"
		CancelBtn.Font = Enum.Font.GothamBold
		CancelBtn.TextSize = 16
		Instance.new("UICorner", CancelBtn).CornerRadius = UDim.new(0,8)
		ApplyNeonStroke(CancelBtn, 1.6)
		NormalizeTextRecursively(CancelBtn)

		ConfirmBtn.MouseButton1Click:Connect(function() ScreenGui:Destroy() end)
		CancelBtn.MouseButton1Click:Connect(function() Overlay:Destroy(); Minimize.Active = true; Close.Active = true end)
	end
	Close.MouseButton1Click:Connect(ShowCloseConfirm)

	-- Window API
	local WindowAPI = {}
	WindowAPI.Window = Window
	WindowAPI.Icon = Icon
	WindowAPI.MiniButton = MiniButton
	function WindowAPI:MakeTab(tbl) return CreateTab(tbl) end

	return WindowAPI
end

setmetatable(Library, {__index = Library})
return Library
